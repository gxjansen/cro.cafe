---
import ErrorBoundary from '../common/ErrorBoundary.astro';
import DOMPurify from 'isomorphic-dompurify';
import { validateProps, EpisodeCardPropsSchema } from '~/utils/component-validation';
import { getEpisodePermalink, getLanguageFromShowId } from '~/utils/permalinks';
import { getEpisodeImage } from '~/utils/images';

// Helper function to strip HTML and truncate text
function sanitizeAndTruncate(html: string, maxLength: number): string {
  // First sanitize the HTML
  const sanitized = DOMPurify.sanitize(html, { ALLOWED_TAGS: [] });
  // Then truncate if needed
  if (sanitized.length <= maxLength) return sanitized;
  // Find the last space before maxLength to avoid cutting words
  const truncated = sanitized.substring(0, maxLength);
  const lastSpace = truncated.lastIndexOf(' ');
  return `${truncated.substring(0, lastSpace)}...`;
}

interface Props {
  episode: {
    id: string;
    type: 'episode';
    attributes: {
      title: string;
      summary: string;
      description: string;
      published_at: string;
      media_url: string;
      duration: number;
      duration_in_mmss: string;
      formatted_published_at: string;
      formatted_description: string;
      image_url?: string;
      video_url?: string;
      transcript_url?: string;
      share_url: string;
      embed_html: string;
      embed_html_dark: string;
      slug: string;
    };
    relationships: {
      show: {
        data: {
          id: string;
          type: string;
        };
      };
    };
  };
  loading?: boolean;
}

// Validate props
const props = validateProps(EpisodeCardPropsSchema, Astro.props);
const { episode, loading = false } = props;
const { title, summary, published_at, formatted_published_at, image_url } = episode.attributes;

// Get language from show ID
const language = getLanguageFromShowId(episode.relationships.show.data.id);

// Get optimized episode image
const image = await getEpisodeImage(image_url, 'card');

// Sanitize and truncate summary
const cleanSummary = sanitizeAndTruncate(summary, 150);

// Prepare ARIA labels
const durationLabel = `Duration: ${episode.attributes.duration_in_mmss}`;
const dateLabel = `Published: ${formatted_published_at}`;
const cardLabel = `Episode: ${title}`;
---

<ErrorBoundary fallback="Episode information unavailable">
  <article 
    class:list={['episode-card', { 'is-loading': loading }]}
    aria-label={cardLabel}
  >
    {loading ? (
      <div class="loading-skeleton">
        <div class="skeleton-image" aria-hidden="true"></div>
        <div class="skeleton-content">
          <div class="skeleton-title" aria-hidden="true"></div>
          <div class="skeleton-date" aria-hidden="true"></div>
          <div class="skeleton-description" aria-hidden="true"></div>
        </div>
      </div>
    ) : (
      <a 
        href={getEpisodePermalink(language, episode.attributes.slug)} 
        class="card-link"
        aria-label={cardLabel}
      >
        <div class="card-image">
          <img
            src={image.src}
            width={image.width}
            height={image.height}
            alt=""
            loading="lazy"
            decoding="async"
            class="w-full h-full object-cover"
            aria-hidden="true"
          />
        </div>
        <div class="card-content">
          <h3 class="card-title">{title}</h3>
          <div class="card-meta">
            <time datetime={published_at} class="card-date" aria-label={dateLabel}>
              {formatted_published_at}
            </time>
            <span class="card-duration" aria-label={durationLabel}>
              {episode.attributes.duration_in_mmss}
            </span>
          </div>
          <p class="card-description">{cleanSummary}</p>
        </div>
      </a>
    )}
  </article>
</ErrorBoundary>

<style>
.episode-card {
  @apply bg-white dark:bg-gray-800 rounded-lg shadow-md overflow-hidden
         transition-transform duration-300 hover:transform hover:scale-[1.02]
         w-full sm:max-w-sm lg:max-w-md mx-auto;
}

.card-link {
  @apply block h-full no-underline;
}

.card-image {
  @apply relative w-full aspect-video overflow-hidden;
}

.card-content {
  @apply p-3 sm:p-4;
}

.card-title {
  @apply text-lg sm:text-xl font-bold mb-1 sm:mb-2 text-gray-900 dark:text-white
         line-clamp-2 hover:text-blue-600 dark:hover:text-blue-400
         leading-tight sm:leading-normal;
}

.card-meta {
  @apply flex items-center gap-2 text-xs sm:text-sm text-gray-500 dark:text-gray-400 mb-1 sm:mb-2;
}

.card-date {
  @apply block;
}

.card-duration {
  @apply flex items-center before:content-['â€¢'] before:mx-2;
}

.card-description {
  @apply text-gray-600 dark:text-gray-300 text-sm mb-2 sm:mb-4 line-clamp-3
         leading-snug sm:leading-relaxed;
}

/* Loading skeleton styles */
.loading-skeleton {
  @apply animate-pulse;
}

.skeleton-image {
  @apply w-full aspect-video bg-gray-200 dark:bg-gray-700;
}

.skeleton-content {
  @apply p-3 sm:p-4 space-y-2 sm:space-y-3;
}

.skeleton-title {
  @apply h-6 sm:h-7 bg-gray-200 dark:bg-gray-700 rounded w-3/4;
}

.skeleton-date {
  @apply h-4 sm:h-5 bg-gray-200 dark:bg-gray-700 rounded w-1/3;
}

.skeleton-description {
  @apply space-y-2;
}

.skeleton-description::before,
.skeleton-description::after {
  @apply content-[''] block h-4 bg-gray-200 dark:bg-gray-700 rounded;
}

.skeleton-description::after {
  @apply w-2/3;
}

/* Focus styles */
.card-link:focus {
  @apply outline-none ring-2 ring-blue-500 ring-offset-2 dark:ring-offset-gray-800;
}

/* Dark mode adjustments */
:global(.dark) .episode-card {
  @apply bg-gray-800;
}
</style>
