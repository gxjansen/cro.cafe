---
import { getCollection } from 'astro:content';
import EpisodeCard from './Card.astro';
import ErrorBoundary from '../common/ErrorBoundary.astro';
import { validateProps, EpisodeGridPropsSchema } from '~/utils/component-validation';

interface Props {
  language: 'en' | 'de' | 'es' | 'nl';
  limit?: number;
  featured?: boolean;
  showGuests?: boolean;
  columns?: '2' | '3' | '4';
}

// Validate props
const props = validateProps(EpisodeGridPropsSchema, Astro.props);
const { 
  language, 
  limit, 
  featured = false, 
  showGuests = true,
  columns = '3'
} = props;

// Get episodes for the specified language
let episodes = [];
try {
  // Debug: Log collection path
  const collectionPath = `${language}/episodes`;
  console.log('Trying to get collection:', collectionPath);
  
  episodes = await getCollection(collectionPath);
  
  // Debug: Log raw collection result
  console.log('Collection result:', {
    path: collectionPath,
    count: episodes.length,
    episodes: episodes.map(e => ({
      id: e.id,
      title: e.data.title,
      date: e.data.date,
      slug: e.slug
    }))
  });
} catch (error) {
  // Log the error for debugging
  console.error('Error getting collection:', error);
  // Continue with empty array
  episodes = [];
}

// Filter and sort episodes
const displayEpisodes = episodes
  .filter(entry => {
    // Skip future episodes
    const isPublished = new Date(entry.data.date) <= new Date();
    // Skip if featured filter is on and episode is not featured
    const meetsFeatureFilter = !featured || entry.data.featured;
    
    // Debug: Log filtering info
    console.log('Filtering episode:', {
      id: entry.id,
      title: entry.data.title,
      date: entry.data.date,
      isPublished,
      meetsFeatureFilter
    });
    
    return isPublished && meetsFeatureFilter;
  })
  .sort((a, b) => new Date(b.data.date).valueOf() - new Date(a.data.date).valueOf())
  // Apply limit if specified
  .slice(0, limit || undefined);

// Debug: Log final episodes
console.log('Final episodes:', displayEpisodes.length);

// Define grid columns class based on prop
const gridClass = {
  '2': 'md:grid-cols-2',
  '3': 'md:grid-cols-2 lg:grid-cols-3',
  '4': 'md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4'
}[columns];
---

<ErrorBoundary fallback="Unable to load episodes. Please try again later.">
  <div class="episode-grid">
    {displayEpisodes.length > 0 ? (
      <div class={`grid gap-6 ${gridClass}`}>
        {displayEpisodes.map((episode) => {
          // Transform episode data to match schema
          const episodeData = {
            id: episode.id,
            title: episode.data.title,
            description: episode.data.description,
            date: episode.data.date,
            audio_url: episode.data.audio_url,
            duration: episode.data.duration,
            language: episode.data.language,
            guests: episode.data.guests || [],
            type: episode.data.type || 'episode'
          };
          
          return (
            <EpisodeCard 
              episode={episodeData} 
              showGuests={showGuests}
            />
          );
        })}
      </div>
    ) : (
      <div class="no-episodes">
        <p>No episodes found.</p>
      </div>
    )}
  </div>
</ErrorBoundary>

<style>
.episode-grid {
  @apply w-full max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8;
}

.no-episodes {
  @apply text-center text-gray-500 dark:text-gray-400 py-12;
}
</style>
