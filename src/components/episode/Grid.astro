---
import EpisodeCard from './Card.astro';
import ErrorBoundary from '../common/ErrorBoundary.astro';
import { validateProps, EpisodeGridPropsSchema } from '~/utils/component-validation';

import type { z } from 'zod';
import type { EpisodeGridPropsSchema } from '~/utils/component-validation';

type Props = z.infer<typeof EpisodeGridPropsSchema>;

// Validate props
const props = validateProps(EpisodeGridPropsSchema, Astro.props);
const { 
  episodes,
  limit,
  featured = false,
  columns = '3',
  loading = false,
  showId,
  season,
  orderBy = 'published_at',
  orderDirection = 'desc',
  button
} = props;

console.log('Grid received episodes:', JSON.stringify(episodes, null, 2));

// Filter and sort episodes
let displayEpisodes = [];
try {
  displayEpisodes = episodes
    .filter(entry => {
      try {
        // Apply filters
        const meetsFeatureFilter = !featured || entry.data.attributes.featured;
        const meetsShowFilter = !showId || entry.data.relationships.show.data.id === showId;
        const meetsSeasonFilter = !season || entry.data.attributes.season === season;
        
        return meetsFeatureFilter && meetsShowFilter && meetsSeasonFilter;
      } catch (error) {
        console.error('Error processing entry:', error);
        return false;
      }
    })
    .sort((a, b) => {
      // Sort by selected criteria
      const aValue = orderBy === 'published_at' 
        ? new Date(a.data.attributes.published_at).getTime()
        : a.data.attributes.duration;
      const bValue = orderBy === 'published_at'
        ? new Date(b.data.attributes.published_at).getTime()
        : b.data.attributes.duration;
        
      return orderDirection === 'desc' ? bValue - aValue : aValue - bValue;
    })
    // Apply limit if specified
    .slice(0, limit || undefined)
    // Transform data structure to match Card.astro expectations
    .map(entry => ({
      id: entry.id,
      type: 'episode',
      attributes: entry.data.attributes,
      relationships: {
        show: {
          data: {
            id: entry.data.relationships.show.data.id,
            type: 'show'
          }
        }
      }
    }));

  console.log('Processed episodes:', JSON.stringify(displayEpisodes[0], null, 2));
} catch (error) {
  console.error('Error processing episodes:', error);
}

// Define grid columns class based on prop
const gridClass = {
  '2': 'sm:grid-cols-2',
  '3': 'sm:grid-cols-2 lg:grid-cols-3',
  '4': 'sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4'
}[columns];

// Generate skeleton cards for loading state
const skeletonCount = limit || 6;

// Prepare ARIA labels
const gridLabel = featured ? 'Featured Episodes' : 'Episode List';
const loadingLabel = 'Loading episodes...';
const noEpisodesLabel = 'No episodes found';
---

<ErrorBoundary fallback="Unable to load episodes. Please try again later.">
  <div class="episode-grid">
    {loading ? (
      <div 
        role="status" 
        aria-label={loadingLabel}
        class={`grid gap-4 sm:gap-6 ${gridClass}`}
      >
        {Array.from({ length: skeletonCount }).map(() => (
          <EpisodeCard
            episode={{
              id: 'skeleton',
              type: 'episode',
              attributes: {
                title: 'Loading...',
                summary: 'Loading...',
                description: 'Loading...',
                published_at: new Date().toISOString(),
                media_url: '',
                duration: 0,
                duration_in_mmss: '00:00',
                formatted_published_at: 'Loading...',
                formatted_description: 'Loading...',
                share_url: '',
                embed_html: '',
                embed_html_dark: '',
                slug: '',
              },
              relationships: {
                show: {
                  data: {
                    id: '',
                    type: 'show',
                  },
                },
              },
            }}
            loading={true}
          />
        ))}
        <div class="sr-only" aria-live="polite">Loading episodes, please wait...</div>
      </div>
    ) : displayEpisodes.length > 0 ? (
      <div class="episode-grid-container">
        <div 
          role="grid" 
          aria-label={gridLabel}
          class={`grid gap-4 sm:gap-6 ${gridClass}`}
          data-grid-nav
        >
          {displayEpisodes.map((episode, index) => (
            <div 
              role="gridcell"
              class="episode-cell"
              tabindex={index === 0 ? 0 : -1}
            >
              <EpisodeCard episode={episode} />
            </div>
          ))}
        </div>
        
        {button?.show && (
          <div class="flex justify-center mt-8">
            <a 
              href={button.link}
              class="btn btn-primary inline-flex items-center gap-2 text-white bg-accent hover:opacity-90 px-6 py-3 rounded-lg transition-colors duration-200"
            >
              {button.text}
              <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
                <path d="M5 12l14 0"></path>
                <path d="M13 18l6 -6"></path>
                <path d="M13 6l6 6"></path>
              </svg>
            </a>
          </div>
        )}
      </div>
    ) : (
      <div 
        class="no-episodes"
        role="status"
        aria-label={noEpisodesLabel}
      >
        <p>No episodes found.</p>
      </div>
    )}
  </div>
</ErrorBoundary>

<style>
.episode-grid {
  @apply w-full max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 sm:py-8;
}

.no-episodes {
  @apply text-center text-gray-500 dark:text-gray-400 py-8 sm:py-12;
}

/* Responsive grid adjustments */
@screen sm {
  .grid {
    @apply grid-cols-2;
  }
}

@screen lg {
  .grid {
    @apply grid-cols-3;
  }
}

@screen xl {
  .grid[class*='grid-cols-4'] {
    @apply grid-cols-4;
  }
}

/* Loading state animation */
@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.loading {
  @apply animate-pulse;
}

/* Focus styles */
.episode-cell:focus-within {
  @apply outline-none ring-2 ring-accent ring-offset-2 dark:ring-offset-gray-800 rounded-lg;
}
</style>
